---
title: "genetic variance due to local ancestry"
author: "Arslan Zaidi"
date: "8/23/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}

library(data.table)
library(ggplot2)
library(dplyr)

```


Simulate genotypes for the two parental populations. We will simulate genotypes for 1000 diploid individuals at 200 loci, each of which has a frequency of 0.8 and 0.3 in pop1 and 2, respectively. 

Set up the parameters.
```{r}

fbar = 0.5 # frequency in the parental population
theta = 0.5 #admixture fraction
nloci = 1e3 #number of loci

vgt = 1 #desired total genetic variance
  
#desired genetic variance in between
vgb = 0.3

#vgb = vgt*Fst
fst = vgb/vgt

#next, calculate frequency difference required to generate that Fst
#fst = (f1 - f2)^2 / 4*pbar*(1-pbar)
fdiff = sqrt(fst*4*fbar*(1-fbar))

#solve system of linear equation
f1_f2 = solve(a = matrix(c(0.5, 1, 0.5, -1), nrow = 2, ncol = 2), 
              b= c(fbar, fdiff))
f1 = f1_f2[1]
f2 = f1_f2[2]

```

```{r}

#simulate genotypes for pop1 (200 loci and 1000 individuals)
geno1 = replicate(nloci, rbinom(200, 2, f1))

#simulate genotypes for pop2
geno2 = replicate(nloci, rbinom(1000, 2, f2))

```

Sample effect sizes for the 200 loci such that the genetic variance in the total population is 0.8. This is not super important but good to understand.

```{r}
#proportion of loci that are causal
pcausal = 0.2
ncausal = round(pcausal*nloci)

#choose effect sizes for causal loci
bg = matrix(
  rnorm(ncausal, 0, sd= sqrt(vgt/(ncausal*2*fbar*(1-fbar)))), 
  nrow = ncausal, ncol = 1)

#standardize to remove stochasticity in realized values
bg = ((bg - mean(bg)) / sd(bg)) * sqrt(vgt/(ncausal*2*fbar*(1-fbar)))

#add 0s for non-causal loci
bg = sample(c(bg, rep(0, nloci - ncausal)))

```
L
Calculate genetic variance between populations

```{r}

#calculate variance between populations
pbar = (f1 + f2)/2
vtotal = sum(2 * bg^2 * fbar * (1 - fbar))
vwithin = sum(2*(bg^2)*f1*(1 - f1) + 2*(bg^2)*f2*(1 - f2))/2
#vb2 = sum(bg^2 * (f2-f1)^2)/2
vbetween = vtotal - vwithin

```

Simulate local ancestry and genotypes for admixed population such that the admixture fraction is 0.5.

Local ancestry at any single locus is assmued to be Binomial with N = 2 and mean = 0.5, the admixture fraction. In other words, the probability of drawing ancestry from population 1 at any locus is 0.5. We assume loci are independent of each other (no LD).

```{r}

#simulate local ancestry in admixed population
#admixture fraction: 0.9
lanc1 = replicate(nloci, rbinom(1e4, 2, 0.9))
lanc2 = replicate(nloci, rbinom(1e4, 2, 0.9))

theta =0.9 # mean admixture fraction
#add some noise to the mean ancestry at each locus due to drift
fst = 10/(2*1e4) # drift since admixture
floci = rbeta(nloci, 0.9*(1- fst)/fst, (1-0.9)*(1-fst)/fst) # mean ancestry fraction at each locus

cormat = matrix(NA, nrow = 100, ncol = 1)
for(i in 1:100){
  lanc1 = replicate(nloci, rbinom(1e3, 2, 0.9))
  lanc2 = replicate(nloci, rbinom(1e3, 2, 0.9))
  glanc1 = apply(lanc1, 1, mean)/2
  glanc2 = apply(lanc2, 1, mean)/2
  cormat[i,1] = cor(glanc1, glanc2)
}


```

Now simulate genotypes at each locus given the ancestry at that locus. If the ancestry of an allele is from pop1, the probability that it is (say the 'A') allele is 0.8. The probability of it being the same allele if the ancestry is from pop2 is 0.3.

```{r }
#simulate genotypes
geno.admix = structure(sapply(lanc, function(x){
  if(x == 0){
    g1 = rbinom(1, 1, f1)
    g2 = rbinom(1, 1, f1)
  }
  if(x == 1){
    g1 = rbinom(1, 1, f1)
    g2 = rbinom(1, 1, f1)
  }
  if(x == 2){
    g1 = rbinom(1, 1, f2)
    g2 = rbinom(1, 1, f2)
  }
  return(g1 + g2)
}), dim = dim(lanc))

```

Simulate genetic values in the admixed population.

```{r}

#generate genetic value in admixed population
gvalue.admix = t(t(bg)%*%t(geno.admix))

```


```{r}

#estimate effect size for genotypes and local ancestry
est.b.g = matrix(NA, nrow = nloci, ncol = 1)
est.b.l = matrix(NA, nrow = nloci, ncol = 1)

for(i in 1:nloci){
  l1 = lm(gvalue.admix ~ geno.admix[,i])
  s1 = summary(l1)$coefficients
  est.b.g[i,1] = s1[2,1]
  
  l2 = lm(gvalue.admix ~ lanc[,i])
  s2 = summary(l2)$coefficients
  est.b.l[i,1] = s2[2,1]
}

```

Expected effect size of local ancestry (based on analytical derivation). Then, plot the expected vs estimated effect size of local ancestry.

```{r}

bl = bg * (f2 - f1) 

#estimated and expected effect size of genotype
plot(bg, est.b.g)

#estimate and expected effect size of ancestry
plot(bl, est.b.l)

```

The correlations look great! The estimated effect size of ancestry is slightly noisier. Will have to work out later what the power of this association test is.

Now, calculate the expected and estimated (using effect sizes not GRM) values of genetic variance due to local ancestry. 

```{r}

#calculate expected genetic variance due to local ancestry
#approach 1: using true genotype effect sizes
exp.vg.ancestry1 = 2*0.5*(1 - 0.5)*sum(bg^2  * (0.8 - 0.3)^2)

#approach 2: using true local ancestry effect sizes
exp.vg.ancestry2 = 2*0.5*(1 - 0.5)*sum(bl^2)

#calculate observed genetic variance due to local ancestry
#approach 1: generate genetic values using estimated effect sizes and calculate variance in genetic values
gvalues.est.lanc = t(t(est.b.l) %*% t(lanc))
obs.vg.ancestry1 = var(gvalues.est.lanc)

#approach 2: square the effect sizes of ancestry and so on.
obs.vg.ancestry2 = sum(est.b.l^2 * 
      2*(apply(lanc, 2, mean)/2) * 
      ( 1- apply(lanc, 2, mean)/2))

data.table(expected = c(exp.vg.ancestry1, exp.vg.ancestry2), 
           observed = c(obs.vg.ancestry1, obs.vg.ancestry2))

```

The expected values are exactly equal to the genetic variance between populations (vbetween). The observed values are slightly higher, probably because the effect sizes are error prone. Let's see if this is just sampling error or if there's some bias in estimation. To do so, we will need to repeat the phenotype and gwas simulation a number of times. 

```{r}

sim.vg_lanc = function(){
  bg = matrix(
    rnorm(nloci, 0, sd= sqrt(vg/(nloci*2*fbar*( 1 - fbar)))), 
    nrow = nloci, ncol = 1)
  
  #generate genetic value in admixed population
  gvalue.admix = t(t(bg)%*%t(geno.admix))
  
  #estimate effect size for genotypes and local ancestry
  est.b.g = matrix(NA, nrow = nloci, ncol = 1)
  est.b.l = matrix(NA, nrow = nloci, ncol = 1)
  
  for(i in 1:nloci){
    # l1 = lm(gvalue.admix ~ geno.admix[,i])
    # s1 = summary(l1)$coefficients
    # est.b.g[i,1] = s1[2,1]
    
    l2 = lm(gvalue.admix ~ lanc[,i])
    s2 = summary(l2)$coefficients
    est.b.l[i,1] = s2[2,1]
  }
  
  #use estimated betas to get best fit values
  #otherwise variance is going to include error variance
  bl = bg*(f2 - f1)
  fitted_b = fitted(lm(est.b.l ~ bl))
  
  obs.vg.ancestry2 = sum(fitted_b^2 * 
                           2*(apply(lanc, 2, mean)/2) * 
                           ( 1- apply(lanc, 2, mean)/2))
  
  return(obs.vg.ancestry2)
  
}

vg_lanc = replicate(100, sim.vg_lanc())


```


```{r}

kmat.l  = lanc %*% t(lanc)

varcomp = function(sg, se){
  ninds = nrow(kmat.l)
  
  S = sg*kmat.l + se*diag(ninds)
  logL = -0.5*2*log(2*pi) + 0.5*log(det(S)) - 0.5 * t(gvalue.admix) %*% inv(S) %*% gvalue.admix
  return(logL)
}

```



